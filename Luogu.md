# 杨辉三角

![  ](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240326004043172.png)

本质： 组合数公式![image-20240326011336127](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240326011336127.png)

---



# 压缩技术

![image-20240328222626989](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240328222626989.png)

> 这段代码的精髓在于：

> 很简单巧妙地处理了怎么在方阵里交替输出01的难点。
> **利用一个Map[]数组存储0或者1的个数，并且使用key在循环中交替变换01**

---



# 压缩技术（续集）

## 题目描述

设某汉字由 $N \times N$ 的 $\texttt 0$ 和 $\texttt 1$ 的点阵图案组成。

我们依照以下规则生成压缩码。连续一组数值：从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从左到右，由上至下。第一个数表示连续有几个 $\texttt 0$，第二个数表示接下来连续有几个 $\texttt 1$，第三个数再接下来连续有几个 $\texttt 0$，第四个数接着连续几个 $\texttt 1$，以此类推……

例如: 以下汉字点阵图案：

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

对应的压缩码是： $\texttt {7 3 1 6 1 6 4 3 1 6 1 6 1 3 7}$ （第一个数是 $N$ ,其余各位表示交替表示0和1 的个数，压缩码保证 $N \times N=$ 交替的各位数之和）

## 输入格式

汉字点阵图（点阵符号之间不留空格）。

## 输出格式

输出一行，压缩码。

## 样例 #1

### 样例输入 #1

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

### 样例输出 #1

```
7 3 1 6 1 6 4 3 1 6 1 6 1 3 7
```

## 提示

数据保证，$3\leq N\leq 200$。



## 代码

![image-20240328224519616](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240328224519616.png)

> 之所以没能解决问题，还是限制于对数组的理解 不一定都是数值。

> 在这道题目中，一开始先输入的数组是个符号数组，然后再使用**strlen**计算n。 比较要注意的是使用了**stract**这个复制函数，输入实际上没有限制。



1. **`if (num == text[i]) sum++;`：如果当前字符与前一个字符相同，则计数器 `sum` 加一。**
2. **`else { num = text[i]; printf("%d ", sum); sum = 1; }`：如果当前字符与前一个字符不同，则输出之前的相同字符的数量，并将计数器 `sum` 重置为 1，同时更新 `num` 为当前字符。**